- hosts: all
  become: true
  vars:
    user: ubuntu
    manifests_dir: manifests/

    internal_ip: 192.168.1.10
  collections:
    - kubernetes.core
  tasks:
    - name: install packages
      apt:
        name:
          - docker.io
          - apt-transport-https
          - ca-certificates
          - curl
          - vim
          - jq
          - yq
        state: present
        update_cache: yes

    - name: check if snapd
      ansible.builtin.apt:
        name: snapd
        state: present
        update_cache: true

    - name: install helm classically
      ansible.builtin.snap:
        name: helm
        classic: yes
        state: present

    - name: add docker user
      user:
        name: "{{ user }}"
        groups: docker
        append: yes

    - name: get lastest stable kubectl
      command: curl -sL https://dl.k8s.io/release/stable.txt
      register: kubectl_version
      changed_when: false
      run_once: true

    - name: download kubectl
      get_url:
        url: "https://dl.k8s.io/release/{{ kubectl_version.stdout }}/bin/linux/amd64/kubectl"
        dest: /usr/local/bin/kubectl
        mode: '0755'
      run_once: true

    - name: download minikube .deb
      get_url:
        url: https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb
        dest: /tmp/minikube.deb
        mode: '0644'
      run_once: true

    - name: install minikube
      apt:
        deb: /tmp/minikube.deb
        state: present
      run_once: true

    - name: reset ssh session
      meta: reset_connection

    - name: run minikube
      become_user: "{{ user }}"
      environment:
        HOME: "/home/{{ user }}"
      shell: |
        sg docker -c "minikube start \
        --driver=docker \
        --memory=4096 \
        --cpus=2 \
        # --kubeconfig=/home/{{ user }}/.kube/config \
        --embed-certs"
      args:
        creates: "/home/{{ user }}/.kube"
    - name: install kubernetes
      apt:
        name:
          - python3-kubernetes
        state: present
        update_cache: yes
    - name: install pyyaml
      apt:
        name:
          - python3-yaml
        state: present

#    - name: install ingress-nginx
#      vars:
#        ansible_shell_executable: /bin/bash
#      shell: |
#        kubectl --kubeconfig /home/{{ user }}/.kube/config   apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
    - name: list manifests
      ansible.builtin.set_fact:
        k8s_manifests: "{{ lookup('ansible.builtin.fileglob', playbook_dir ~ '/{{ manifests_dir }}/*.yaml', wantlist=True) }}"

    - name: Sync manifest dir
      ansible.builtin.synchronize:
        src: "{{ playbook_dir }}/{{ manifests_dir }}"
        dest: "/home/{{ user }}/manifests"
        recursive: yes
      delegate_to: localhost
      vars:
        ansible_become: false

    - name: apply manifests
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ user }}/.kube/config"
        state: present
        src: "/home/{{ user }}/{{ manifests_dir }}/{{ item | basename }}"
        namespace: default
      loop: "{{ k8s_manifests }}"
      loop_control:
        label: "{{ item | basename }}"


    - name: Получить объект Node текущего хоста
      kubernetes.core.k8s_info:
        kubeconfig: "/home/{{ user }}/.kube/config"
        api_version: v1
        kind: Node
        #name: "{{ inventory_hostname }}"
      register: node_info

    - set_fact:
        internal_node_ip: >-
          {{
            node_info.resources[0].status.addresses
            | selectattr('type', 'equalto', 'InternalIP')
            | map(attribute='address')
            | first
          }}

    - name: Дебаг — убедиться, что IP есть
      debug:
        msg: "INTERNAL IP = {{ internal_node_ip }}"

    - name: Create Prometheus volume
      community.docker.docker_volume:
        name: prometheus_data
    - name: Создать директорию для конфига Prometheus, если её нет
      ansible.builtin.file:
        path: /etc/prometheus
        state: directory
        owner: root
        group: root
        mode: '0755'
      become: true
#    - name: «Задеплоить» конфиг Prometheus с нужным IP
#      template:
#        src: prometheus.j2
#        dest: /etc/prometheus/prometheus.yml
#        owner: root
#        group: root
#        mode: '0644'
#      vars:
#        internal_ip: "{{ internal_node_ip }}"   # переменная заранее получена или передана в playbook
    - name: Создать директорию для конфига Prometheus, если её нет
      ansible.builtin.file:
        path: "/home/{{ user }}/prometheus"
        state: directory
        owner: 65534
        group: 65534
        mode: '0755'
      become: true



    - name: copy prometheus
      copy:
        dest: /etc/prometheus/prometheus.yml
        content: |
          global:
            scrape_interval: 15s
          scrape_configs:
            - job_name: node-exporter
              static_configs:
                - targets: ['{{ internal_node_ip }}:31000']
            - job_name: kube-state-metrics
              static_configs:
                - targets: ['{{ internal_node_ip }}:31001']
            - job_name: backend-state-metrics
              static_configs:
                - targets: ['{{ internal_node_ip }}:31002']
            - job_name: frontend-state-metrics
              static_configs:
                - targets: ['{{ internal_node_ip }}:31003']

#    - name: Запустить Prometheus в режиме host-network
#      community.docker.docker_container:
#        name: prometheus
#        image: prom/prometheus:latest
#        state: started
#        network_mode: host               # аналог --network host
#        published_ports:                 # -p … (необязательно при host-network, но безвредно)
#          - "9090:9090"
#          - "31000:31000"
#          - "31001:31001"
#        volumes:                        # -v …:ro и -v …
#          - src: /etc/prometheus/prometheus.yml
#            dest: /etc/prometheus/prometheus.yml
#            read_only: true
#            type: bind
#          - src: /etc/prometheus
#            dest: /prometheus
#            type: bind
#            #owner: 65534           # UID nobody
#            #group: 65534           # GID nobody
#            #recurse: yes           # аналог -R
#            #mode: '0777'
#        command:
#          - "--config.file=/etc/prometheus/prometheus.yml"
#          - "--storage.tsdb.path=/prometheus"
#        restart_policy: unless-stopped
    - name: Run prometheus
      become_user: "{{ user }}"
      shell: |
         docker rm --force prometheus 2>/dev/null && \
         docker run \
         --detach \
         --rm \
         --name prometheus \
         --network host \
          -p9090:9090 \
          -p31000:31000 \
          -p31001:31001 \
          -p31002:31002 \
          -p31003:31003 \
         --volume /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro \
         --volume /home/ubuntu/prometheus:/prometheus prom/prometheus \
         --config.file=/etc/prometheus/prometheus.yml \
         --storage.tsdb.path=/prometheus

#    - name: Run Prometheus
#      community.docker.docker_container:
#        name: prometheus
#        image: prom/prometheus:latest
#        ports:
#          - "9090:9090"
#        volumes:
#          #prometheus_data:/etc/prometheus/
#          /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
#          prometheus_data:/prometheus_data
#        restart_policy: unless-stopped
#        command: --config.file=/etc/prometheus/prometheus.yml
    - name: Add prometheus community
      ansible.builtin.command: >
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
      args:
        creates: "{{ ansible_env.HOME }}/.config/helm/repositories/repositories.yaml"

    - name: Обновить локальный индекс чартов
      ansible.builtin.command: helm repo update
    - name: Установить node-exporter с NodePort
      kubernetes.core.helm:

        kubeconfig: "/home/{{ user }}/.kube/config"
        name: node-exporter
        chart_ref: prometheus-community/prometheus-node-exporter
        namespace: monitoring
        create_namespace: true
        values:
          service:
            type: NodePort      # тип сервиса для проброса порта наружу
            nodePort: 31000     # порт на каждой ноде (30000–32767)
      # helm-chart prometheus-node-exporter по умолчанию поддерживает service.type и service.nodePort :contentReference[oaicite:0]{index=0}

    - name: Установить kube-state-metrics с NodePort
      kubernetes.core.helm:

        kubeconfig: "/home/{{ user }}/.kube/config"
        name: kube-state-metrics
        chart_ref: prometheus-community/kube-state-metrics
        namespace: monitoring
        create_namespace: true
        values:
          service:
            type: NodePort
            nodePort: 31001





   # - name: install prometheus agent
   #   kubernetes.core.helm:

   #     kubeconfig: "/home/{{ user }}/.kube/config"
   #     name: prometheus-agent
   #     chart_ref: prometheus-community/prometheus
   #     namespace: monitoring
   #     create_namespace: true
   #     values:
   #       server:
   #         enabled: false
   #       service:
   #         type: NodePort
   #         nodePort: 30090
   #       remoteWrite:
   #         - url: "http://{{ internal_ip }}:30090/api/v1/write"


    - name: Sync grafana proviisioning dir
      ansible.builtin.synchronize:
        src: "{{ playbook_dir }}/grafana_provisioning_vm"
        dest: "/home/{{ user }}/"
        recursive: yes
      delegate_to: localhost
      vars:
        ansible_become: false

    - name: Create Grafana volume
      community.docker.docker_volume:
        name: grafana_data
    - name: Run Grafana
      community.docker.docker_container:
        name: grafana
        image: grafana/grafana:latest
        network_mode: host
        ports:
          - "3000:3000"
        volumes:
          -  "/home/{{ user }}/grafana_provisioning_vm/:/home/grafana/grafana_provisioning/"
        env:
          GF_SECURITY_ADMIN_USER: admin
          GF_SECURITY_ADMIN_PASSWORD: admin
          GF_PATHS_CONFIG: /home/grafana/grafana_provisioning/grafana.ini
          GF_PATHS_PROVISIONING: /home/grafana/grafana_provisioning/
        restart_policy: unless-stopped
